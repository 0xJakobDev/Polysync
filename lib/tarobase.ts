// Generated by TaroBase SDK Generator: 2025-10-05T11:54:32.857Z
// Edits may be overwritten by subsequent runs!

import { get, set, subscribe, setMany as tarobaseSetMany } from '@tarobase/js-sdk';
import { getFiles, setFile } from '@tarobase/js-sdk';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@tarobase/js-sdk'; 


// --- SDK Utilities ---

/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value: any): value is TimeOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "time" &&
    value.value === "now"
  );
};

/**
 * Time utility for server-time values
 *
 * Use this when you want to store the current server time in a numeric field
 *
 * Example:
 * // For a schema with { createdAt: "Int" } or { createdAt: "UInt" }
 * await setPost("123", {
 *   title: "My Post",
 *   createdAt: Time.Now  // Will be stored as the server's current timestamp
 * });
 */
export interface TimeOperation {
  operation: string;
  value: string;
}

export type TokenName = 'USDC' | 'SOL' | 'other';
export interface TokenAmount {
  type: 'token';
  name: TokenName;
  amount: number; // User-friendly amount (e.g., 10.5 SOL)
}

/**
 * AddressType represents a Solana public key for use in request data.
 */
export interface AddressType {
  type: 'address';
  publicKey: PublicKey | string;
}

/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value: any): value is TokenAmount => {
  return value && typeof value === 'object' && value.type === 'token';
};

/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value: any): value is AddressType => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};


/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data: any): any => {
  // Handle null or non-object/array types directly
  if (!data || typeof data !== 'object') {
    return data;
  }

  // Check for specific object types first using type guards
  if (isServerTimeNow(data)) {
    // Pass Time.Now object as is; backend interprets it
    return { operation: 'time', value: 'now' };
  } else if (isTokenAmount(data)) {
    // Convert user-friendly amount to backend's integer format based on decimals
    const { name, amount } = data; // Safe access due to type guard
    if (name === 'USDC') {
      return Math.round(amount * 10 ** 6); // 6 decimals for USDC
    } else if (name === 'SOL') {
      return Math.round(amount * 10 ** 9); // 9 decimals for SOL
    } else {
      // Assume a default of 6 decimals for custom tokens
      return Math.round(amount * 10 ** 6);
    }
  } else if (isAddressType(data)) {
     // Convert AddressType to its base58 string representation for the backend
     if (typeof data.publicKey === 'string') {
      return data.publicKey;
     } else {
      return data.publicKey.toBase58(); // Safe access due to type guard
     }
  }

  // Handle arrays: recursively transform each item
  if (Array.isArray(data)) {
    // Use map with explicit typing for clarity
    return data.map((item: any) => transformValues(item));
  }

  // Handle regular objects: recursively transform each property
  // Create a new object to avoid modifying the original
  const result: Record<string, any> = {};
  for (const key in data) {
    // Use safer check for own properties
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      result[key] = transformValues(data[key]);
    }
  }
  return result;
};

// --- SDK Helper Objects ---

export const Token: {
  /**
   * Creates a TokenAmount object representing a specific amount of a token.
   * @param name The name of the token (e.g., 'USDC', 'SOL').
   * @param amount The user-friendly amount (e.g., 10.5 for 10.5 USDC).
   */
  amount: (name: TokenName, amount: number) => TokenAmount;
  /**
   * Converts a TokenAmount object back to its integer representation based on decimals.
   * Useful if you need the raw integer value on the client side.
   */
  convert: (amount: TokenAmount) => number;
} = {
  amount: (name: TokenName, amount: number): TokenAmount => ({
    type: 'token',
    name,
    amount,
  }),
  convert: (amount: TokenAmount): number => {
    // This logic mirrors the transformation in transformValues
    if (amount.name === 'USDC') {
      return Math.round(amount.amount * 10 ** 6);
    } else if (amount.name === 'SOL') {
      return Math.round(amount.amount * 10 ** 9);
    }
    return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
  },
};

export const Time: {
  /**
   * Represents the server's current time. Use this value for 'Int' or 'UInt' fields
   * in request data where you want the server to insert the timestamp.
   */
  Now: TimeOperation;
} = {
  Now: { operation: "time", value: "now" }
};

export const Address: {
  /**
   * Creates an AddressType object from a PublicKey instance or a base58 string.
   * Validates the input and throws an error if invalid.
   * @param key A PublicKey instance or a base58 encoded public key string.
   */
  publicKey: (key: PublicKey | string) => AddressType;
} = {
  publicKey: (key: PublicKey | string): AddressType => {
    let pkInstance: PublicKey;
    if (typeof key === 'string') {
      try {
        // Validate and create PublicKey from string
        pkInstance = new PublicKey(key);
      } catch (e) {
        // Safer error handling
        const message = e instanceof Error ? e.message : String(e);
        console.error(`Invalid public key string provided: ${key}`, message);
        throw new Error(`Invalid public key string: ${key}`);
      }
    } else if (key instanceof PublicKey) {
       // Use the provided PublicKey instance directly
      pkInstance = key;
    } else {
      // Handle invalid input type
      throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
    }
    // Return the structured AddressType object
    return {
      type: 'address',
      publicKey: pkInstance,
    };
  },
};

// --- Common Interfaces ---
/**
 * Common metadata fields added by TaroBase to document responses.
 */
export interface TarobaseMetadata {
  id: string;
  tarobase_created_at: number; // epoch milliseconds
}

/**
 * Represents a file stored in TaroBase Storage.
 */
export interface FileItem {
  path: string; // Full path within storage
  url: string;  // Publicly accessible URL
}

/**
 * Represents a document operation for use with setMany.
 * Used by build functions to create properly typed operations.
 */
export interface DocumentOperation {
  path: string;
  document: any;
}

// --- Batch Operations ---

/**
 * Execute multiple document operations in a single batch.
 * @param operations Array of DocumentOperation objects created by build functions
 * @returns Promise resolving to the result of the batch operation
 */
export async function setMany(operations: DocumentOperation[]): Promise<any> {
  return await tarobaseSetMany(operations);
}

// --- Generated Functions by Policy Path ---

// --- Path: uniblock/$requestId ---

// --- Path: uniblock/$requestId --- (Uniblock – typed wrappers, hard‑coded requestId=1)

export type UniblockChainId =
  | 'solana'
  | 'solana-devnet'
  | 1 | 8453 | 42161 | number;

export interface WalletTokenBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletTokenBalanceResponseItem { contractAddress: string; balance: string; name: string; symbol: string; logo: string; decimals: string; }
export interface WalletTokenBalanceResponse { balances: WalletTokenBalanceResponseItem[]; }
export async function getWalletTokenBalance({ walletAddress, chainId = 'solana' }: WalletTokenBalanceParams): Promise<WalletTokenBalanceResponse> {
  const body = { operationId: 'WalletTokenBalance', operationInputData: { walletAddress, chainId, includePrice: true } };
  return (await set("uniblock/1", body)) as WalletTokenBalanceResponse;
}

export interface TokenPriceParams { contractAddress: string; chainId?: UniblockChainId; }
export interface TokenPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; }
export async function getTokenPrice({ contractAddress, chainId = 'solana' }: TokenPriceParams): Promise<TokenPriceResponse> {
  const body = { operationId: 'TokenPrice', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenPriceResponse;
}

export interface TokenHistoricalPriceParams { contractAddress: string; chainId?: UniblockChainId; timestamp?: number; blockNumber?: number; }
export interface TokenHistoricalPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; blockNumber: string; timestamp: string; }
export async function getTokenHistoricalPrice({ contractAddress, chainId = 'solana', timestamp, blockNumber }: TokenHistoricalPriceParams): Promise<TokenHistoricalPriceResponse> {
  const body = { operationId: 'TokenHistoricalPrice', operationInputData: { contractAddress, chainId, timestamp, blockNumber } };
  return (await set("uniblock/1", body)) as TokenHistoricalPriceResponse;
}

export interface WalletNFTBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletNFTBalanceResponseItem { contractAddress: string; tokenId: string; name: string; symbol: string; image: string; }
export interface WalletNFTBalanceResponse { balances: WalletNFTBalanceResponseItem[]; }
export async function getWalletNFTBalance({ walletAddress, chainId = 'solana' }: WalletNFTBalanceParams): Promise<WalletNFTBalanceResponse> {
  const body = { operationId: 'WalletNFTBalance', operationInputData: { walletAddress, chainId } };
  return (await set("uniblock/1", body)) as WalletNFTBalanceResponse;
}

export interface NFTCollectionMetadataParams { contractAddress: string; chainId?: UniblockChainId; }
export interface NFTCollectionMetadataResponse { address: string; name: string; symbol: string; type: string; }
export async function getNFTCollectionMetadata({ contractAddress, chainId = 'solana' }: NFTCollectionMetadataParams): Promise<NFTCollectionMetadataResponse> {
  const body = { operationId: 'NFTCollectionMetadata', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as NFTCollectionMetadataResponse;
}

export interface NFTMetadataParams { contractAddress: string; tokenId: string; chainId?: UniblockChainId; }
export interface NFTMetadataResponse { contractAddress: string; contractType: string; metadata: any; rawMetadata: string; lastUpdated: string; contractMetadata: any; }
export async function getNFTMetadata({ contractAddress, tokenId, chainId = 'solana' }: NFTMetadataParams): Promise<NFTMetadataResponse> {
  const body = { operationId: 'NFTMetadata', operationInputData: { contractAddress, tokenId, chainId } };
  return (await set("uniblock/1", body)) as NFTMetadataResponse;
}

export interface TokenMetadataParams { tokenAddress: string; chainId?: UniblockChainId; }
export interface TokenMetadataResponse { name: string; symbol: string; logo: string; decimals: string; }
export async function getTokenMetadata({ tokenAddress, chainId = 'solana' }: TokenMetadataParams): Promise<TokenMetadataResponse> {
  const body = { operationId: 'TokenMetadata', operationInputData: { tokenAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenMetadataResponse;
}
// --- Path: appFiles/$fileId ---

/**
 * Handles AppFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAppFiles(fileId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`appFiles/${fileId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles AppFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAppFiles function right after this one.
 */
export async function uploadAppFiles(fileId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `appFiles/${fileId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- Path: uploadedImages/$imageId ---

/**
 * Handles UploadedImages files (Get Single File based on its ID, null if not found)
 */
export async function getUploadedImages(imageId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`uploadedImages/${imageId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles UploadedImages files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getUploadedImages function right after this one.
 */
export async function uploadUploadedImages(imageId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `uploadedImages/${imageId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Handles UploadedImages files (Delete File based on its ID, returns true if successful)
 */
export async function deleteUploadedImages(imageId: string): Promise<boolean> {
  try {
    await setFile(`uploadedImages/${imageId}`, null);
    return true;
  } catch (error) {
    console.error(`Error deleting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- Path: agents/$agentId ---

export interface AgentsRequest {
  owner: AddressType;
  name: string;
  description?: string;
  avatarUri?: string;
  targetWallet: AddressType;
  copyRatio: number | TimeOperation | TokenAmount;
  retryLimit: number | TimeOperation | TokenAmount;
  initialOrderTimeout: number | TimeOperation | TokenAmount;
  secondOrderIncrement: number | TimeOperation | TokenAmount;
  secondOrderTimeout: number | TimeOperation | TokenAmount;
  finalOrderIncrement: number | TimeOperation | TokenAmount;
  finalOrderTimeout: number | TimeOperation | TokenAmount;
  protectionLevel: string;
  status: string;
  createdAt?: number | TimeOperation | TokenAmount;
}

export interface AgentsResponse {
  owner: string;
  name: string;
  description?: string;
  avatarUri?: string;
  targetWallet: string;
  copyRatio: number;
  retryLimit: number;
  initialOrderTimeout: number;
  secondOrderIncrement: number;
  secondOrderTimeout: number;
  finalOrderIncrement: number;
  finalOrderTimeout: number;
  protectionLevel: string;
  status: string;
  createdAt?: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a Agents operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildAgents(agentId: string, data: AgentsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `agents/${agentId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Authenticated user; caller must equal @newData.owner.
Goal: Create and save a new trading agent configuration.
Preconditions:
  - @newData.owner == @user.address
  - copyRatio (basis points) is between 1 and 10000 inclusive.
  - retryLimit and all timeout values are positive.
Steps (client):
  1) Generate a unique $agentId client-side (reuse on retries).
  2) Create agents/$agentId with the fields documented below.
Hooks that will execute (on success): None.
Postconditions: A new agent document exists with status="inactive".
What the client should do next:
  - Show the agent in the dashboard. Provide controls to start the bot via backend API.
Notes:
  - Units: copyRatio is basis points; timeout/increment fields are UInt seconds or cents.
  - Idempotency/Retries: Reuse $agentId on retries. (Create/Update Single Item)
 */
export async function setAgents(agentId: string, data: AgentsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`agents/${agentId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting Agents: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type AgentsRequestUpdate = Partial<AgentsRequest>;

/**
 * Build a Agents update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateAgents(agentId: string, data: AgentsRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `agents/${agentId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Only the agent owner.
Goal: Modify trading parameters or status (e.g., set status="active").
Preconditions:
  - @data.owner == @user.address AND @data.owner == @newData.owner.
Steps (client):
  1) PATCH only the fields that need to change (do not alter owner).
Hooks that will execute (on success): None.
Postconditions: Fields updated.
What the client should do next:
  - Refetch the agent; update UI accordingly.
Notes:
  - Idempotency/Retries: Safe to retry the same payload. (Update Single Item)
 */
export async function updateAgents(agentId: string, data: AgentsRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`agents/${agentId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating Agents: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: UI/API How-To:
Who: Anyone (public list) or the owner filtering via queries.
Goal: Retrieve trading agent configuration and status.
Preconditions: None.
Steps (client):
  1) Read agents/$agentId or list agents collection.
Hooks that will execute (on success): None (off-chain collection).
Postconditions: None.
What the client should do next:
  - Render agent details. If viewer is owner, enable Edit / Delete / Start / Stop controls.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
   (Get Single Item)
 */
export async function getAgents(agentId: string): Promise<AgentsResponse | null> {
  try {
    const result = await get(`agents/${agentId}`);
    return result as AgentsResponse | null;
  } catch (error) {
    console.error(`Error getting Agents: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single Agents document. (
  Read Operation Details: UI/API How-To:
Who: Anyone (public list) or the owner filtering via queries.
Goal: Retrieve trading agent configuration and status.
Preconditions: None.
Steps (client):
  1) Read agents/$agentId or list agents collection.
Hooks that will execute (on success): None (off-chain collection).
Postconditions: None.
What the client should do next:
  - Render agent details. If viewer is owner, enable Edit / Delete / Start / Stop controls.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  )
 */
export function subscribeAgents(callback: (data: AgentsResponse | null) => void, agentId: string): Promise<() => Promise<void>> {
  return subscribe(`agents/${agentId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as AgentsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to Agents at path '${`agents/${agentId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many Agents items from collection agents
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public list) or the owner filtering via queries.
Goal: Retrieve trading agent configuration and status.
Preconditions: None.
Steps (client):
  1) Read agents/$agentId or list agents collection.
Hooks that will execute (on success): None (off-chain collection).
Postconditions: None.
What the client should do next:
  - Render agent details. If viewer is owner, enable Edit / Delete / Start / Stop controls.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export async function getManyAgents(filter: string = ""): Promise<AgentsResponse[]> {
  try {
    const results = await get("agents", { prompt: filter });
    return Array.isArray(results) ? results as AgentsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Agents collection at path 'agents': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Agents collection at agents
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public list) or the owner filtering via queries.
Goal: Retrieve trading agent configuration and status.
Preconditions: None.
Steps (client):
  1) Read agents/$agentId or list agents collection.
Hooks that will execute (on success): None (off-chain collection).
Postconditions: None.
What the client should do next:
  - Render agent details. If viewer is owner, enable Edit / Delete / Start / Stop controls.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export function subscribeManyAgents(callback: (data: AgentsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("agents", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as AgentsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Agents collection at path '${"agents"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all Agents items from collection agents
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public list) or the owner filtering via queries.
Goal: Retrieve trading agent configuration and status.
Preconditions: None.
Steps (client):
  1) Read agents/$agentId or list agents collection.
Hooks that will execute (on success): None (off-chain collection).
Postconditions: None.
What the client should do next:
  - Render agent details. If viewer is owner, enable Edit / Delete / Start / Stop controls.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export async function getAllAgents(filter: string = ""): Promise<AgentsResponse[]> {
  try {
    const results = await get("agents", { prompt: filter });
    return Array.isArray(results) ? results as AgentsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Agents collection at path 'agents': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Agents collection at agents
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public list) or the owner filtering via queries.
Goal: Retrieve trading agent configuration and status.
Preconditions: None.
Steps (client):
  1) Read agents/$agentId or list agents collection.
Hooks that will execute (on success): None (off-chain collection).
Postconditions: None.
What the client should do next:
  - Render agent details. If viewer is owner, enable Edit / Delete / Start / Stop controls.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export function subscribeAllAgents(callback: (data: AgentsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("agents", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as AgentsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Agents collection at path '${"agents"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * 
  Delete Operation Details: UI/API How-To:
Who: Only the agent owner.
Goal: Permanently remove an agent configuration.
Preconditions:
  - @data.owner == @user.address.
Steps (client):
  1) DELETE agents/$agentId.
Hooks that will execute (on success): None.
Postconditions: Document removed.
What the client should do next:
  - Stop any running backend bot, then remove the UI card.
Notes:
  - Idempotency/Retries: Deleting a non-existent doc is a no-op.
   (Delete Single Item)
 */
export async function deleteAgents(agentId: string): Promise<boolean> {
  try {
    const succeeded = await set(`agents/${agentId}`, null);
    return !!succeeded;
  } catch (error) {
    console.error(`Error deleting Agents: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Build a delete operation for Agents for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildDeleteAgents(agentId: string): DocumentOperation {
  return { path: `agents/${agentId}`, document: null };
}

// --- Path: agentEscrows/$agentId/deposits/$depositId ---

export interface AgentEscrowsDepositsRequest {
  depositor: AddressType;
  amountLamports: number | TimeOperation | TokenAmount;
}

export interface AgentEscrowsDepositsResponse {
  depositor: string;
  amountLamports: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a AgentEscrowsDeposits operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildAgentEscrowsDeposits(agentId: string, depositId: string, data: AgentEscrowsDepositsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `agentEscrows/${agentId}/deposits/${depositId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Authenticated depositor; caller must equal @newData.depositor.
Goal: Deposit SOL into the agent escrow so the automated bot can trade.
Preconditions:
  - @newData.depositor == @user.address
  - @newData.amountLamports > 0
Steps (client):
  1) Generate unique $depositId.
  2) Create agentEscrows/$agentId/deposits/$depositId with { depositor, amountLamports }.
Hooks that will execute (on success):
  - Ensures an escrow PDA exists for $agentId via @AccountPlugin.createAccount.
  - Transfers SOL from depositor → escrow PDA.
Postconditions: Escrow balance increases by amountLamports.
What the client should do next:
  - Refresh agent balance display via queries if implemented.
Notes:
  - Units: amountLamports are in lamports (1 SOL = 1_000_000_000 lamports).
  - Idempotency/Retries: Reuse $depositId to avoid double-charging on retry. (Create/Update Single Item)
 */
export async function setAgentEscrowsDeposits(agentId: string, depositId: string, data: AgentEscrowsDepositsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`agentEscrows/${agentId}/deposits/${depositId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting AgentEscrowsDeposits: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: UI/API How-To:
Who: Anyone (public history).
Goal: Inspect deposit records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read agentEscrows/$agentId/deposits/$depositId or list deposits to show history.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Show confirmation / history entry if needed.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
   (Get Single Item)
 */
export async function getAgentEscrowsDeposits(agentId: string, depositId: string): Promise<AgentEscrowsDepositsResponse | null> {
  try {
    const result = await get(`agentEscrows/${agentId}/deposits/${depositId}`);
    return result as AgentEscrowsDepositsResponse | null;
  } catch (error) {
    console.error(`Error getting AgentEscrowsDeposits: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single AgentEscrowsDeposits document. (
  Read Operation Details: UI/API How-To:
Who: Anyone (public history).
Goal: Inspect deposit records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read agentEscrows/$agentId/deposits/$depositId or list deposits to show history.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Show confirmation / history entry if needed.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  )
 */
export function subscribeAgentEscrowsDeposits(callback: (data: AgentEscrowsDepositsResponse | null) => void, agentId: string, depositId: string): Promise<() => Promise<void>> {
  return subscribe(`agentEscrows/${agentId}/deposits/${depositId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as AgentEscrowsDepositsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to AgentEscrowsDeposits at path '${`agentEscrows/${agentId}/deposits/${depositId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many AgentEscrowsDeposits items from collection agentEscrows/${agentId}/deposits
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public history).
Goal: Inspect deposit records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read agentEscrows/$agentId/deposits/$depositId or list deposits to show history.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Show confirmation / history entry if needed.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export async function getManyAgentEscrowsDeposits(agentId: string, filter: string = ""): Promise<AgentEscrowsDepositsResponse[]> {
  try {
    const results = await get(`agentEscrows/${agentId}/deposits`, { prompt: filter });
    return Array.isArray(results) ? results as AgentEscrowsDepositsResponse[] : [];
  } catch (error) {
    console.error(`Error getting AgentEscrowsDeposits collection at path 'agentEscrows/${agentId}/deposits': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in AgentEscrowsDeposits collection at agentEscrows/${agentId}/deposits
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public history).
Goal: Inspect deposit records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read agentEscrows/$agentId/deposits/$depositId or list deposits to show history.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Show confirmation / history entry if needed.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export function subscribeManyAgentEscrowsDeposits(callback: (data: AgentEscrowsDepositsResponse[]) => void, agentId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`agentEscrows/${agentId}/deposits`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as AgentEscrowsDepositsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to AgentEscrowsDeposits collection at path '${`agentEscrows/${agentId}/deposits`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all AgentEscrowsDeposits items from collection agentEscrows/${agentId}/deposits
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public history).
Goal: Inspect deposit records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read agentEscrows/$agentId/deposits/$depositId or list deposits to show history.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Show confirmation / history entry if needed.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export async function getAllAgentEscrowsDeposits(agentId: string, filter: string = ""): Promise<AgentEscrowsDepositsResponse[]> {
  try {
    const results = await get(`agentEscrows/*/deposits`, { prompt: filter });
    return Array.isArray(results) ? results as AgentEscrowsDepositsResponse[] : [];
  } catch (error) {
    console.error(`Error getting AgentEscrowsDeposits collection at path 'agentEscrows/${agentId}/deposits': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in AgentEscrowsDeposits collection at agentEscrows/${agentId}/deposits
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public history).
Goal: Inspect deposit records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read agentEscrows/$agentId/deposits/$depositId or list deposits to show history.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Show confirmation / history entry if needed.
Notes:
  - Idempotency/Retries: Reads are safe to retry.
  
 */
export function subscribeAllAgentEscrowsDeposits(callback: (data: AgentEscrowsDepositsResponse[]) => void, agentId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`agentEscrows/*/deposits`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as AgentEscrowsDepositsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to AgentEscrowsDeposits collection at path '${`agentEscrows/*/deposits`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getEscrowBalance" query on AgentEscrowsDeposits.
 * Query Logic: @TokenPlugin.getBalance($agentId, @TokenPlugin.SOL)
 */
export async function runGetEscrowBalanceQueryForAgentEscrowsDeposits(agentId: string, depositId: string, ): Promise<number> {
  try {
    const result = await runQuery(`agentEscrows/${agentId}/deposits/${depositId}`, "getEscrowBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getEscrowBalance" on AgentEscrowsDeposits: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: agentEscrows/$agentId/withdrawals/$withdrawalId ---

export interface AgentEscrowsWithdrawalsRequest {
  requestor: AddressType;
  amountLamports: number | TimeOperation | TokenAmount;
}

export interface AgentEscrowsWithdrawalsResponse {
  requestor: string;
  amountLamports: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a AgentEscrowsWithdrawals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildAgentEscrowsWithdrawals(agentId: string, withdrawalId: string, data: AgentEscrowsWithdrawalsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `agentEscrows/${agentId}/withdrawals/${withdrawalId}`, document: doc };
}

/**
 * UI/API How-To:
Who: Authenticated user requesting withdrawal.
Goal: Withdraw SOL from the agent escrow back to the caller's wallet.
Preconditions:
  - @newData.requestor == @user.address
  - @newData.amountLamports > 0
  - @newData.amountLamports <= @TokenPlugin.getBalance($agentId, @TokenPlugin.SOL)
Steps (client):
  1) Generate unique $withdrawalId.
  2) Create agentEscrows/$agentId/withdrawals/$withdrawalId with { requestor, amountLamports }.
Hooks that will execute (on success):
  - Transfers SOL from escrow PDA → requestor wallet.
Postconditions: Escrow balance decreases.
What the client should do next:
  - Refresh balances.
Notes:
  - Units: lamports.
  - Idempotency/Retries: Reuse $withdrawalId to safely retry. (Create/Update Single Item)
 */
export async function setAgentEscrowsWithdrawals(agentId: string, withdrawalId: string, data: AgentEscrowsWithdrawalsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`agentEscrows/${agentId}/withdrawals/${withdrawalId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting AgentEscrowsWithdrawals: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: UI/API How-To:
Who: Anyone (public audit).
Goal: Inspect withdrawal records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read withdrawals to view history.
Hooks that will execute (on success): None.
Postconditions: None.
   (Get Single Item)
 */
export async function getAgentEscrowsWithdrawals(agentId: string, withdrawalId: string): Promise<AgentEscrowsWithdrawalsResponse | null> {
  try {
    const result = await get(`agentEscrows/${agentId}/withdrawals/${withdrawalId}`);
    return result as AgentEscrowsWithdrawalsResponse | null;
  } catch (error) {
    console.error(`Error getting AgentEscrowsWithdrawals: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single AgentEscrowsWithdrawals document. (
  Read Operation Details: UI/API How-To:
Who: Anyone (public audit).
Goal: Inspect withdrawal records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read withdrawals to view history.
Hooks that will execute (on success): None.
Postconditions: None.
  )
 */
export function subscribeAgentEscrowsWithdrawals(callback: (data: AgentEscrowsWithdrawalsResponse | null) => void, agentId: string, withdrawalId: string): Promise<() => Promise<void>> {
  return subscribe(`agentEscrows/${agentId}/withdrawals/${withdrawalId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as AgentEscrowsWithdrawalsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to AgentEscrowsWithdrawals at path '${`agentEscrows/${agentId}/withdrawals/${withdrawalId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many AgentEscrowsWithdrawals items from collection agentEscrows/${agentId}/withdrawals
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public audit).
Goal: Inspect withdrawal records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read withdrawals to view history.
Hooks that will execute (on success): None.
Postconditions: None.
  
 */
export async function getManyAgentEscrowsWithdrawals(agentId: string, filter: string = ""): Promise<AgentEscrowsWithdrawalsResponse[]> {
  try {
    const results = await get(`agentEscrows/${agentId}/withdrawals`, { prompt: filter });
    return Array.isArray(results) ? results as AgentEscrowsWithdrawalsResponse[] : [];
  } catch (error) {
    console.error(`Error getting AgentEscrowsWithdrawals collection at path 'agentEscrows/${agentId}/withdrawals': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in AgentEscrowsWithdrawals collection at agentEscrows/${agentId}/withdrawals
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public audit).
Goal: Inspect withdrawal records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read withdrawals to view history.
Hooks that will execute (on success): None.
Postconditions: None.
  
 */
export function subscribeManyAgentEscrowsWithdrawals(callback: (data: AgentEscrowsWithdrawalsResponse[]) => void, agentId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`agentEscrows/${agentId}/withdrawals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as AgentEscrowsWithdrawalsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to AgentEscrowsWithdrawals collection at path '${`agentEscrows/${agentId}/withdrawals`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all AgentEscrowsWithdrawals items from collection agentEscrows/${agentId}/withdrawals
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public audit).
Goal: Inspect withdrawal records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read withdrawals to view history.
Hooks that will execute (on success): None.
Postconditions: None.
  
 */
export async function getAllAgentEscrowsWithdrawals(agentId: string, filter: string = ""): Promise<AgentEscrowsWithdrawalsResponse[]> {
  try {
    const results = await get(`agentEscrows/*/withdrawals`, { prompt: filter });
    return Array.isArray(results) ? results as AgentEscrowsWithdrawalsResponse[] : [];
  } catch (error) {
    console.error(`Error getting AgentEscrowsWithdrawals collection at path 'agentEscrows/${agentId}/withdrawals': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in AgentEscrowsWithdrawals collection at agentEscrows/${agentId}/withdrawals
 
  Read Operation Details: UI/API How-To:
Who: Anyone (public audit).
Goal: Inspect withdrawal records for an agent escrow.
Preconditions: None.
Steps (client):
  1) Read withdrawals to view history.
Hooks that will execute (on success): None.
Postconditions: None.
  
 */
export function subscribeAllAgentEscrowsWithdrawals(callback: (data: AgentEscrowsWithdrawalsResponse[]) => void, agentId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`agentEscrows/*/withdrawals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as AgentEscrowsWithdrawalsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to AgentEscrowsWithdrawals collection at path '${`agentEscrows/*/withdrawals`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getEscrowBalance" query on AgentEscrowsWithdrawals.
 * Query Logic: @TokenPlugin.getBalance($agentId, @TokenPlugin.SOL)
 */
export async function runGetEscrowBalanceQueryForAgentEscrowsWithdrawals(agentId: string, withdrawalId: string, ): Promise<number> {
  try {
    const result = await runQuery(`agentEscrows/${agentId}/withdrawals/${withdrawalId}`, "getEscrowBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getEscrowBalance" on AgentEscrowsWithdrawals: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: recoveryKeys/$userId ---

export interface RecoveryKeysRequest {
  encryptedKey: string;
}

export interface RecoveryKeysResponse {
  encryptedKey: string;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a RecoveryKeys operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildRecoveryKeys(userId: string, data: RecoveryKeysRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `recoveryKeys/${userId}`, document: doc };
}

/**
 * UI/API How-To:
Who: The user only ($userId).
Goal: Import an encrypted recovery key and store it securely.
Preconditions:
  - @user.address == $userId
  - @newData.encryptedKey != null
Steps (client):
  1) Encrypt the recovery key client-side.
  2) Write recoveryKeys/$userId with { encryptedKey }.
Hooks that will execute (on success): None.
Postconditions: Key is stored.
What the client should do next:
  - Show confirmation message.
Notes:
  - Never send plaintext keys to the server.
  - Idempotency/Retries: Overwrite allowed via update if needed. (Create/Update Single Item)
 */
export async function setRecoveryKeys(userId: string, data: RecoveryKeysRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`recoveryKeys/${userId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting RecoveryKeys: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type RecoveryKeysRequestUpdate = Partial<RecoveryKeysRequest>;

/**
 * Build a RecoveryKeys update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateRecoveryKeys(userId: string, data: RecoveryKeysRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `recoveryKeys/${userId}`, document: doc };
}

/**
 * UI/API How-To:
Who: The user only ($userId).
Goal: Replace or rotate the encrypted recovery key.
Preconditions:
  - @user.address == $userId
  - @newData.encryptedKey != null
Steps (client):
  1) Encrypt new key.
  2) PATCH encryptedKey field.
Hooks that will execute (on success): None.
Postconditions: Key updated.
What the client should do next:
  - Confirm update to user. (Update Single Item)
 */
export async function updateRecoveryKeys(userId: string, data: RecoveryKeysRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`recoveryKeys/${userId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating RecoveryKeys: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: UI/API How-To:
Who: The user only ($userId).
Goal: Retrieve the user's encrypted recovery key for export or verification.
Preconditions:
  - @user.address == $userId
Steps (client):
  1) Read recoveryKeys/$userId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Display recovery key status; never show decrypted key in UI.
Notes:
  - Idempotency/Retries: Safe to retry reads.
   (Get Single Item)
 */
export async function getRecoveryKeys(userId: string): Promise<RecoveryKeysResponse | null> {
  try {
    const result = await get(`recoveryKeys/${userId}`);
    return result as RecoveryKeysResponse | null;
  } catch (error) {
    console.error(`Error getting RecoveryKeys: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single RecoveryKeys document. (
  Read Operation Details: UI/API How-To:
Who: The user only ($userId).
Goal: Retrieve the user's encrypted recovery key for export or verification.
Preconditions:
  - @user.address == $userId
Steps (client):
  1) Read recoveryKeys/$userId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Display recovery key status; never show decrypted key in UI.
Notes:
  - Idempotency/Retries: Safe to retry reads.
  )
 */
export function subscribeRecoveryKeys(callback: (data: RecoveryKeysResponse | null) => void, userId: string): Promise<() => Promise<void>> {
  return subscribe(`recoveryKeys/${userId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as RecoveryKeysResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to RecoveryKeys at path '${`recoveryKeys/${userId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many RecoveryKeys items from collection recoveryKeys
 
  Read Operation Details: UI/API How-To:
Who: The user only ($userId).
Goal: Retrieve the user's encrypted recovery key for export or verification.
Preconditions:
  - @user.address == $userId
Steps (client):
  1) Read recoveryKeys/$userId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Display recovery key status; never show decrypted key in UI.
Notes:
  - Idempotency/Retries: Safe to retry reads.
  
 */
export async function getManyRecoveryKeys(filter: string = ""): Promise<RecoveryKeysResponse[]> {
  try {
    const results = await get("recoveryKeys", { prompt: filter });
    return Array.isArray(results) ? results as RecoveryKeysResponse[] : [];
  } catch (error) {
    console.error(`Error getting RecoveryKeys collection at path 'recoveryKeys': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in RecoveryKeys collection at recoveryKeys
 
  Read Operation Details: UI/API How-To:
Who: The user only ($userId).
Goal: Retrieve the user's encrypted recovery key for export or verification.
Preconditions:
  - @user.address == $userId
Steps (client):
  1) Read recoveryKeys/$userId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Display recovery key status; never show decrypted key in UI.
Notes:
  - Idempotency/Retries: Safe to retry reads.
  
 */
export function subscribeManyRecoveryKeys(callback: (data: RecoveryKeysResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("recoveryKeys", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as RecoveryKeysResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to RecoveryKeys collection at path '${"recoveryKeys"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all RecoveryKeys items from collection recoveryKeys
 
  Read Operation Details: UI/API How-To:
Who: The user only ($userId).
Goal: Retrieve the user's encrypted recovery key for export or verification.
Preconditions:
  - @user.address == $userId
Steps (client):
  1) Read recoveryKeys/$userId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Display recovery key status; never show decrypted key in UI.
Notes:
  - Idempotency/Retries: Safe to retry reads.
  
 */
export async function getAllRecoveryKeys(filter: string = ""): Promise<RecoveryKeysResponse[]> {
  try {
    const results = await get("recoveryKeys", { prompt: filter });
    return Array.isArray(results) ? results as RecoveryKeysResponse[] : [];
  } catch (error) {
    console.error(`Error getting RecoveryKeys collection at path 'recoveryKeys': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in RecoveryKeys collection at recoveryKeys
 
  Read Operation Details: UI/API How-To:
Who: The user only ($userId).
Goal: Retrieve the user's encrypted recovery key for export or verification.
Preconditions:
  - @user.address == $userId
Steps (client):
  1) Read recoveryKeys/$userId.
Hooks that will execute (on success): None.
Postconditions: None.
What the client should do next:
  - Display recovery key status; never show decrypted key in UI.
Notes:
  - Idempotency/Retries: Safe to retry reads.
  
 */
export function subscribeAllRecoveryKeys(callback: (data: RecoveryKeysResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("recoveryKeys", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as RecoveryKeysResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to RecoveryKeys collection at path '${"recoveryKeys"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * 
  Delete Operation Details: UI/API How-To:
Who: The user only ($userId).
Goal: Remove stored recovery key (dangerous; user may lose access).
Preconditions:
  - @user.address == $userId
Steps (client):
  1) DELETE recoveryKeys/$userId.
Hooks that will execute (on success): None.
Postconditions: Key removed.
What the client should do next:
  - Warn user about consequences.
Notes:
  - Idempotency/Retries: Deleting a non-existent doc is a no-op.
   (Delete Single Item)
 */
export async function deleteRecoveryKeys(userId: string): Promise<boolean> {
  try {
    const succeeded = await set(`recoveryKeys/${userId}`, null);
    return !!succeeded;
  } catch (error) {
    console.error(`Error deleting RecoveryKeys: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Build a delete operation for RecoveryKeys for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildDeleteRecoveryKeys(userId: string): DocumentOperation {
  return { path: `recoveryKeys/${userId}`, document: null };
}

// --- End Generated SDK ---
